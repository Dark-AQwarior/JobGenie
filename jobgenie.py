# -*- coding: utf-8 -*-
"""BAJobGenieDaily

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13m0dnVEG49e4PKDCZjlJIvFAHA2h5Vqf
"""

from google.colab import drive
drive.mount('/content/drive')

pip install -U python-jobspy

!wget -q -O chrome.deb https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb
!dpkg -i chrome.deb
!apt-get -fy install

!pip install selenium webdriver-manager undetected-chromedriver

import os

# Set your credentials (Replace with your actual credentials)
os.environ["SENDER_EMAIL"] = "agrapavi@gmail.com"  # Replace with your sender email
os.environ["APP_PASSWORD"] = "yjwy gvof vbeh ughe"  # Replace with your generated Gmail App Password
os.environ["RECIPIENT_EMAIL"] = "agrapavi@gmail.com"  # Replace with the recipient email

print("‚úÖ Environment variables set successfully!")

logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s", force=True)

import csv
import os
import smtplib
import logging
import pandas as pd
from jobspy import scrape_jobs
from email.message import EmailMessage

# Configure logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")

# Email Configuration (Ensure environment variables are set)
SMTP_SERVER = "smtp.gmail.com"
SMTP_PORT = 587  # Explicitly define the SMTP port
SENDER_EMAIL = os.environ.get("SENDER_EMAIL")
APP_PASSWORD = os.environ.get("APP_PASSWORD")
RECIPIENT_EMAIL = os.environ.get("RECIPIENT_EMAIL")

if not all([SENDER_EMAIL, APP_PASSWORD, RECIPIENT_EMAIL]):
    logging.error("Missing environment variables. Ensure SENDER_EMAIL, APP_PASSWORD, and RECIPIENT_EMAIL are set.")
    exit()

# Job Roles (Relevant Computer Science fields)
job_roles = [
    "Business Analyst", "BI Analyst", "Data Business Analyst", "Business Data Analyst",
    "Business Systems Analyst", "IT Business Analyst", "Technical Business Analyst",
    "Reporting Analyst", "Strategy Analyst", "Decision Analyst", "Insights Analyst",
    "Financial Business Analyst", "Product Analyst", "Process Analyst", "Operations Analyst",
    "Business Operations Analyst", "Agile Business Analyst", "Digital Business Analyst",
    "Systems Analyst", "Associate Business Analyst", "Graduate Business Analyst"
]

# Experience Levels (Entry-level, 0-3 years)
experience_filters = ["0-3 years", "Entry Level", "Junior", "Freshers", "1+ years", "2+ years", "Associate"]

# Exclusion filters
senior_exclusion_keywords = ["Senior", "Staff", "Lead", "Principal", "Director", "Sr.", "Head", "Expert"]
non_cs_exclusion_keywords = [
    "Civil Engineer", "Mechanical", "Electrical Engineer", "Doctor", "Nurse",
    "Pharmacist", "HR", "Marketing", "Sales", "Finance", "Accounting",
    "Construction", "Architect", "Legal", "Therapist", "Dentist",
    "Physical Therapy", "Retail", "Fashion", "Customer Service",
    "Professor", "Biology", "Chemistry", "Physics", "Biotech"
]
exclusion_keywords = ["US citizen", "US citizenship", "Green card", "security clearance"]

# Master DataFrame
all_jobs_df = pd.DataFrame()

def fetch_jobs(search_term, location="USA", results_wanted=50, hours_old=24):
    """Fetch job listings, filter relevant jobs, and return as DataFrame."""
    try:
        logging.info(f"üîç Searching for jobs: {search_term}...")
        jobs = scrape_jobs(
            site_name=["linkedin", "indeed", "zip_recruiter", "google"],
            search_term=search_term,
            google_search_term=f"{search_term} software jobs in {location} since yesterday",
            location=location,
            results_wanted=results_wanted,
            hours_old=hours_old,
            country_indeed="USA",
        )

        if jobs.empty:
            logging.warning(f"‚ö†Ô∏è No jobs found for {search_term}.")
            return pd.DataFrame()

        # Apply all filtering in a single step
        filtered_jobs = jobs[
            ~jobs["description"].str.contains("|".join(exclusion_keywords), case=False, na=False) &
            jobs["title"].str.contains("|".join(job_roles), case=False, na=False) &
            (jobs["title"].str.contains("|".join(experience_filters), case=False, na=False) |
             jobs["description"].str.contains("|".join(experience_filters), case=False, na=False)) &
            ~jobs["title"].str.contains("|".join(senior_exclusion_keywords), case=False, na=False) &
            ~jobs["title"].str.contains("|".join(non_cs_exclusion_keywords), case=False, na=False)
        ].copy()  # üî• Ensuring it's an independent DataFrame (important!)

        if filtered_jobs.empty:
            logging.warning(f"‚ö†Ô∏è No suitable jobs found for {search_term} after filtering.")
            return pd.DataFrame()

        # ‚úÖ Fix the warning by using `.loc[:, "column"]`
        filtered_jobs.loc[:, "search_term"] = search_term  # Now modifies safely

        return filtered_jobs

    except Exception as e:
        logging.error(f"‚ùå Error fetching jobs for {search_term}: {e}")
        return pd.DataFrame()

# Fetch and filter jobs for each job role (optimized)
for role in job_roles:
    logging.info(f"üöÄ Starting job search for role: {role}")  # ‚úÖ Added log statement
    jobs_df = fetch_jobs(role)
    if not jobs_df.empty:
        all_jobs_df = pd.concat([all_jobs_df, jobs_df], ignore_index=True)

# Save jobs to CSV
final_csv_filename = "JobGenieMagic.csv"
if not all_jobs_df.empty:
    all_jobs_df.drop_duplicates(subset=["job_url" if "job_url" in all_jobs_df.columns else "title"], keep="first", inplace=True)
    all_jobs_df.to_csv(final_csv_filename, quoting=csv.QUOTE_NONNUMERIC, escapechar="\\", index=False)
    logging.info(f"‚úÖ Final unique jobs saved in {final_csv_filename}")
else:
    logging.warning("‚ö†Ô∏è No jobs found to save.")

# Email Sending Function
def send_email_with_attachment(file):
    """Send an email with the combined job CSV file attached."""
    if not os.path.exists(file):
        logging.warning("‚ö†Ô∏è No file to send. Exiting email function.")
        return

    msg = EmailMessage()
    msg["Subject"] = "üî• JobGenie üßû‚Äç‚ôÇÔ∏è - Fresh 0-3 Year Tech Roles! - DailyPaper"
    msg["From"] = SENDER_EMAIL
    msg["To"] = RECIPIENT_EMAIL

    # Email Body
    email_body = """\
    <html>
        <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333;">
            <h2 style="color: #4CAF50;">Hello Future Tech Superstar! üåü</h2>

            <p>I hope this email finds you <strong>smiling, motivated, and ready to take on the world</strong>! üí™‚ú®</p>

            <p>Here‚Äôs your daily list of <strong>fresh job listings</strong> that match your skills and experience (0-3 years):</p>

            <ul>
                <li>üìÇ <strong>Handpicked jobs from top platforms</strong></li>
                <li>üîç <strong>No 'US Citizenship Required' filters</strong></li>
                <li>üöÄ <strong>Your gateway to an exciting tech career!</strong></li>
            </ul>

            <p>Take a deep breath, grab your favorite coffee ‚òï, and check out these listings! The right job is out there waiting for someone <strong>exactly like you</strong>‚Äîsmart, ambitious, and full of potential.</p>

            <h3 style="color: #ff5722;">You got this! üéØüåü</h3>

            <p><em>Wishing you success,</em></p>
            <p><strong>JobGenie Bot üßû‚Äç‚ôÇÔ∏èü§ñ</strong></p>
        </body>
    </html>
    """
    msg.add_alternative(email_body, subtype="html")

    # Attach file
    with open(file, "rb") as f:
        msg.add_attachment(f.read(), maintype="application", subtype="csv", filename=file)

    # Send email
    try:
        with smtplib.SMTP(SMTP_SERVER, SMTP_PORT) as server:
            server.starttls()
            server.login(SENDER_EMAIL, APP_PASSWORD)
            server.send_message(msg)
        logging.info("‚úÖ Email sent successfully!")
    except Exception as e:
        logging.error(f"‚ùå Failed to send email: {e}")

# Send email
send_email_with_attachment(final_csv_filename)